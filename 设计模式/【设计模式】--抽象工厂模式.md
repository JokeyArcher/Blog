# 设计模式 —— 抽象工厂模式

## 简介

在了解抽象工厂模式之前，我们必须先了解一个概念**产品族**。所谓的**产品族**，是指位于不同产品等级结构中，功能相关联的产品组成的家族。
举个例子：在肥宅心中除了快乐水最喜欢的就是动漫了。
![产品族](https://user-gold-cdn.xitu.io/2019/2/26/16929329778f3a88?w=671&h=383&f=png&s=9590)
在上面的图中，国产动漫和日本动漫称为两个不同的等级结构；而热血番和搞笑番则称为两个不同的产品族。具体点就是。国漫的热血番和搞笑番属于同一等级结构，日漫的热血番和搞笑番属于同一等级结构；国漫和日漫的热血番属于同一产品族，国漫和日漫的搞笑番属于同一产品族。

**抽象工厂模式**（Abstract Factory Pattern）是为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。

## 实例

就以动漫为例子：

产品接口定义：

```java
// 热血番剧
public interface BloodDrama {
    String name();
}
// 搞笑番剧
public interface FunnyDrama {
    String name();
}
```

产品具体实现：

```java
// 中国热血番
public class ChinaBloodDrama implements BloodDrama {
    @Override
    public String name() {
        return "中国热血番";
    }
}
// 中国搞笑番
public class ChinaFunnyDrama implements FunnyDrama {
    @Override
    public String name() {
        return "中国搞笑番";
    }
}
//日本热血番
public class JapanBloodDrama implements BloodDrama {
    @Override
    public String name() {
        return "日本热血番";
    }
}
//日本搞笑番
public class JapanFunnyDrama implements FunnyDrama {
    @Override
    public String name() {
        return "日本搞笑番";
    }
}
```

工厂接口定义：

```java
public interface Factory {
    BloodDrama createBloodDrama();
    FunnyDrama createFunnyDrama();
}
```

工厂具体实现：

```java
// 国漫工厂
public class ChinaAnimeFactory implements Factory {
    @Override
    public BloodDrama createBloodDrama() {
        return new ChinaBloodDrama();
    }

    @Override
    public FunnyDrama createFunnyDrama() {
        return new ChinaFunnyDrama();
    }
}

// 日漫工厂
public class JapanAnimeFactory implements Factory {
    @Override
    public BloodDrama createBloodDrama() {
        return new JapanBloodDrama();
    }

    @Override
    public FunnyDrama createFunnyDrama() {
        return new JapanFunnyDrama();
    }
}
```

客户端（肥宅）：

```java
public class Fz {
    @Test
    public void watch() {
        // 国漫工厂
        Factory chinaAnimeFactory = new ChinaAnimeFactory();
        System.out.println("肥宅观看：" + chinaAnimeFactory.createBloodDrama().name());
        System.out.println("肥宅观看：" + chinaAnimeFactory.createFunnyDrama().name());

        // 日漫工厂
        Factory japanAnimeFactory = new JapanAnimeFactory();
        System.out.println("肥宅观看：" + japanAnimeFactory.createBloodDrama().name());
        System.out.println("肥宅观看：" + japanAnimeFactory.createFunnyDrama().name());
    }
}
```

## 优点

抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。

## 缺点

产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。

## 适用场景

当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。

## 抽象工厂模式与工厂方法模式的区别

## 总结
